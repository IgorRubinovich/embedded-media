<dom-module id="embedded-media"> 
	<style>
		:host {
			display : inline-block;
		}
		#content {
			position : relative;
		}
		#cover {
			position : absolute;
			top : 0;
			left : 0;
			background : red; /* good for testing */
			opacity  : 0.5;
		}
		#aspectKeeper {
			width : 100%;
			height : 0;
		}
	</style>
	<template>
		<div id="content"><div id="aspectKeeper"><content></content></div><div id="cover"></div></div>
	</template>
</dom-module>

<script>
	(function () {
		Polymer({
			is : 'embedded-media',
			
			properties : [
				{ 
					name : "originalInnerHTML",
					type : String
				},
				{ 
					name : "width",
					type : Number,
					notify : true,
					observer : "widthChanged"
				},
				{ 
					name : "aspect",
					type : Number,
					notify : true,
				}
			],
			
			widthChangedIframe : function() {
				console.log('!! widthChangedIframe');

				var aspect, w, h, bcr = this.$.content.getBoundingClientRect();
				
				if(!(w = this.getAttribute('width')))
					w = this.iframe.width || bcr.width || this.$.content.scrollWidth;
				if(!(h = this.getAttribute('height')))
					h = this.iframe.height || bcr.height || this.$.content.scrollHeight;

				aspect = h / w;

				// set aspect attribute if not yet set
				if(!this.aspect && !(this.aspect = this.getAttribute('aspect')))
				{
					this.aspect = aspect;
					this.setAttribute('aspect', aspect);
				}
				else
					aspect = this.aspect;

				h = w * aspect;

				this.iframe.width = w;
				this.iframe.height = h;

				this.iframe.setAttribute('width', w);
				this.iframe.setAttribute('height', h);
				
				this.updateStyles(w, h);
			},
			
			// for scripted embeds like Twitter
			_widthChangedScript : function(reason) {
				var domMutated = reason == "domMutated";
			
				console.log('!! widthChangedScript');
				var aspect, w, h, bcr = this.$.content.getBoundingClientRect(), maxw, maxh, update, minh, maxh;

				if(domMutated || !(w = this.width || this.getAttribute('width')))
					w = bcr.width || this.$.content.scrollWidth;

				h = this.$.content.scrollHeight || bcr.height;
				
				if(!(w && h))
					return;
					
				if(!domMutated)
					this.width || this.getAttribute('width', w);

				console.log();

				this.updateStyles(w, h, reason);
			},
			
			
			widthChangedScript : function(ev, postfactum) {
				var w, h, childNodes = this.$.aspectKeeper.childNodes, cw, ch;
				if(postfactum)
				{
					cw =  Array.prototype.filter.call(childNodes, function(el){ return el.clientWidth }).map(function(el) { return el.clientWidth });
					ch =  Array.prototype.filter.call(childNodes, function(el){ return el.clientHeight }).map(function(el) { return el.clientHeight });

					if(cw.length)
					{
						this.maxw = Math.max.apply({}, cw);
						this.minw = Math.min.apply({}, cw);
					}
					if(ch.length)
					{
						this.maxh = Math.max.apply({}, ch);
						this.minh = ch.reduce(function(p, c) { return p + c });
					}

					console.log("maxw: %s, minw: %s, maxh: %s, minh: %s, ", this.maxw, this.minw, this.maxh, this.minh);

					if(postfactum == 1)
						this.lastTimeout = setTimeout(function () { this.widthChangedScript(ev, 2); }.bind(this), 300 ); // check one more time because observer seems not to fire between last change and actual relayout

					return this._widthChangedScript(ev);
				}

				this.maxw = this.minw = this.maxh = this.minh = 0;

				this._widthChangedScript(ev);

				if(this.lastTimeout)
					clearTimeout(this.lastTimeout);

				if(!postfactum)
					this.lastTimeout = setTimeout(function () { this.widthChangedScript(ev, 1); }.bind(this), ev == 'domChanged' ? 200 : 50); // check one more time because observer seems not to fire between last change and actual relayout
			},

			widthChanged : function(ev) {
				if(this.iframe)
					this.widthChangedIframe();
				else
					this.widthChangedScript(ev);

			},

			updateStyles : function(w, h, reason) {
				this.maxw && (w = Math.min(w, this.maxw));
				this.minw && (w = Math.max(w, this.minw));
				this.maxh && (h = Math.min(h, this.maxh));
				this.minh && (h = Math.max(h, this.minh));
				
				this.setAttribute('width', this.width = w);
				this.setAttribute('height', this.height = h);
				
				this.$.content.style.width = w + "px";
				this.style.width = w + "px";

				this.$.content.style.height = h + "px";
				this.style.height = h + "px";

				if(!this.isInContentEditable)
					return;

				//cm = parseInt(getComputedStyle(this).marginLeft);
				//if(!cm)
				//	this.style.marginLeft = "2px";
				
				this.$.cover.style.width = w + "px";
				this.$.cover.style.height = h + "px";
			},
			
			attributeChanged : function(name) {
				if(name == 'width')
					this.widthChanged('attributeChanged');
			},
			
			ready : function() {
				this.originalInnerHTML = this.$.aspectKeeper.innerHTML;
				this.firstAttachment = true;
			},
			
			attached : function() {
				var p = this, firstChild, iframe, w, h, rect, mutationObserver, oconfig, cm;
				// if(!this.firstAttachment)
				// return;

				var interval, iframe = Polymer.dom(this).querySelector('iframe');
				this.iframe = Polymer.dom(this).childNodes.length && iframe;
				
				while(p.nodeType == 1 && (p = Polymer.dom(p).parentNode))
					if(p.hasAttribute && p.hasAttribute("contenteditable"))
						this.isInContentEditable = true;
				
				mutationObserver = new MutationObserver(function(mr) {
					this.widthChanged('domMutated');
				}.bind(this));
				
				oconfig = {
					childList : true,
					subtree : true,
					characterData : true
				}
				
				//if(!iframe)
				//	oconfig.attributes = true;
								
				mutationObserver.observe(this.$.content, oconfig);

				//swapChildren(Polymer.dom(this));
				
				swapScripts(this);
				
			    if(this.firstAttachment && typeof(FB) != 'undefined') {
					// init script must be run by page master:
					// (function(d, s, id) { var js, fjs = d.getElementsByTagName(s)[0]; if (d.getElementById(id)) return; js = d.createElement(s); js.id = id; js.src = "//connect.facebook.net/en_US/all.js#xfbml=1"; fjs.parentNode.insertBefore(js, fjs); }(document, 'script', 'facebook-jssdk'));
					FB.XFBML.parse();
				}
				
				Polymer.dom.flush();
				this.widthChanged();
				
				this.firstAttachment = false;
			},
			
			domChanged : function() {
				console.log('dom changed!')
			}
		})
		
				
		function swapScripts (d) {
			var clone, attrs, pn;
			
			//document.body.appendChild(d);
			
			var s = Polymer.dom(d).querySelectorAll('script'), i;
			
			for(i = 0; i < s.length; i++)
			{
				clone = document.createElement('script');
				clone.appendChild(document.createTextNode(s[i].textContent));
				attrs = Array.prototype.slice.call(s[i].attributes);
				attrs.forEach(function(a) { clone.setAttribute(a.name, a.value); });

				pn = Polymer.dom(s[i]).parentNode; //Polymer.dom(s[i]).parentNode;

				if(!pn)
					return;

				Polymer.dom(pn).insertBefore(clone, s[i]);
				Polymer.dom(pn).removeChild(s[i]);
			}
			
			return s.length;
			//document.body.removeChild(d);
		}
		
		function swapChildren(d, skip) {
			var i, f = document.createDocumentFragment();;
			for(i = 0; i < d.childNodes.length; i++)
				f.appendChild(d.childNodes[i]);
			
			d.parentNode.appendChild(f, d);
			//d.parentNode.removeChild(d);
		}
	})();
</script>
