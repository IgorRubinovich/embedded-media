<dom-module id="embedded-media"> 
	<style>
		:host {
			display : inline-block;
		}
		#content {
			position : relative;
		}
		#cover {
			position : absolute;
			top : 0;
			left : 0;
			background : red; /* good for testing */
			opacity  : 0.5;
		}
		#aspectKeeper {
			width : 100%;
			height : 0;
		}
	</style>
	<template>
		<div id="content"><div id="aspectKeeper"><content></content></div><div id="cover"></div></div>
	</template>
</dom-module>

<script>
	(function () {
		Polymer({
			is : 'embedded-media',
			
			properties : [
				{ 
					name : "originalInnerHTML",
					type : String
				},
				{ 
					name : "width",
					type : Number,
					notify : true,
					observer : "widthChanged"
				},
				{ 
					name : "aspect",
					type : Number,
					notify : true,
				}
			],
			
			widthChangedIframe : function() {
				console.log('!! widthChangedIframe');

				var aspect, w, h, bcr = this.$.content.getBoundingClientRect();
				
				if(!(w = this.getAttribute('width')))
					w = this.iframe.width || bcr.width || this.$.content.scrollWidth;
				if(!(h = this.getAttribute('height')))
					h = this.iframe.height || bcr.height || this.$.content.scrollHeight;

				aspect = h / w;

				// set aspect attribute if not yet set
				if(!this.aspect && !(this.aspect = this.getAttribute('aspect')))
				{
					this.aspect = aspect;
					this.setAttribute('aspect', aspect);
				}
				else
					aspect = this.aspect
				
				h = w * aspect;

				if(this.isInContentEditable)
				{
					this.style.width = this.$.cover.style.width = w + "px";
					this.style.height = this.$.cover.style.height = h + "px";
				}
					//this.$.cover.style.marginTop = "-" + h + "px";

				this.width = this.iframe.width = w;
				this.height = this.iframe.height = h;

				this.iframe.setAttribute('width', w);
				this.iframe.setAttribute('height', h);
			},
			
			// for scripted embeds like Twitter
			widthChangedScript : function(reason) {
				var domMutated = reason == "domMutated";
			
				console.log('!! widthChangedScript');
				var aspect, w, h, bcr = this.$.content.getBoundingClientRect(), maxw, maxh, update;

				if(domMutated || !(w = this.width || this.getAttribute('width')))
					w = bcr.width || this.$.content.scrollWidth;

				h = this.$.content.scrollHeight || bcr.height;
				
				if(!(w && h))
					return;
					
				if(!domMutated)
					this.width || this.getAttribute('width', w);

				console.log();

				if(this.maxw && this.maxw < w)
					w = this.maxw;
				if(this.maxh && this.maxh < h)
					h = this.maxh;

				this.updateStyles(w, h);
				
				if(bcr.width < this.$.content.scrollWidth)
				{
					w = this.$.content.scrollWidth;
					h = this.$.content.scrollHeight;
					this.updateStyles(w, h);
				}
				else
				if(reason == 'attributeChanged')
				{
					maxw = Math.max.apply({}, Array.prototype.map.call(this.$.aspectKeeper.childNodes, function(el) { return el.clientWidth || 0 }));
					if(maxw < w) // || maxh < h)
					{
						this.updateStyles(maxw, h);
						w = this.maxw = maxw;
					}
					maxh = Math.max.apply({}, Array.prototype.map.call(this.$.aspectKeeper.childNodes, function(el) { return el.clientHeight || 0 }));
					if(maxh < h) // || maxh < h)
					{
						this.updateStyles(w, maxh);
					}
				}

				//this.updateStyles(w, h);
			},

			updateStyles : function(w, h) {
				this.$.content.style.width = w + "px";
				this.$.content.style.height = h + "px";
				this.style.width = w + "px";
				this.style.height = h + "px";
				
				if(!this.isInContentEditable)
					return;

				this.$.cover.style.width = w + "px";
				this.$.cover.style.height = h + "px";
			},

			widthChanged : function(ev, postfactum) {
				var bcr, domMutated = (ev == true);

				if(postfactum)
					if(this.iframe)
						this.widthChangedIframe();
					else
						this.widthChangedScript(ev);

				if(this.lastTimeout)
					clearTimeout(this.lastTimeout);

				if(!postfactum)
				{
					this.lastTimeout = setTimeout(function () { this.widthChanged(ev, true) }.bind(this), 50); // check one more time because observer seems not to fire between last change and actual relayout
					//setTimeout(function () { this.widthChanged(ev, true) }.bind(this), 1000);
				}
				
				return;
			},
			
			attributeChanged : function(name) {
				if(name == 'width')
					this.widthChanged('attributeChanged');
			},
			
			ready : function() {
				this.originalInnerHTML = this.$.aspectKeeper.innerHTML;
				this.firstAttachment = true;
			},
			
			attached : function() {
				var p = this, firstChild, iframe, w, h, rect, mutationObserver;
				// if(!this.firstAttachment)
				// return;

				var interval, iframe = Polymer.dom(this).querySelector('iframe');
				this.iframe = Polymer.dom(this).childNodes.length && iframe;
				
				while(p.nodeType == 1 && (p = Polymer.dom(p).parentNode))
					if(p.hasAttribute && p.hasAttribute("contenteditable"))
						this.isInContentEditable = true;

				mutationObserver = new MutationObserver(function(mr) {
					this.widthChanged('domMutated');
				}.bind(this));
				
				mutationObserver.observe(this.$.content, {
					childList : true,
					subtree : true,
					characterData : true,
					attributes : true
				});
								
				//swapChildren(Polymer.dom(this));
				
			    if(this.firstAttachment && typeof(FB) != 'undefined') {
					// init script must be run by page master:
					// (function(d, s, id) { var js, fjs = d.getElementsByTagName(s)[0]; if (d.getElementById(id)) return; js = d.createElement(s); js.id = id; js.src = "//connect.facebook.net/en_US/all.js#xfbml=1"; fjs.parentNode.insertBefore(js, fjs); }(document, 'script', 'facebook-jssdk'));
					FB.XFBML.parse();
				}
				
				swapScripts(this);
				
				Polymer.dom.flush();
				this.widthChanged();
				
				this.firstAttachment = false;
			},
			
			domChanged : function() {
				console.log('dom changed!')
			}
		})
		
				
		function swapScripts (d) {
			var clone, attrs, pn;
			
			//document.body.appendChild(d);
			
			var s = Polymer.dom(d).querySelectorAll('script'), i;
			
			for(i = 0; i < s.length; i++)
			{
				clone = document.createElement('script');
				clone.appendChild(document.createTextNode(s[i].textContent));
				attrs = Array.prototype.slice.call(s[i].attributes);
				attrs.forEach(function(a) { clone.setAttribute(a.name, a.value); });

				pn = Polymer.dom(s[i]).parentNode; //Polymer.dom(s[i]).parentNode;

				if(!pn)
					return;

				Polymer.dom(pn).insertBefore(clone, s[i]);
				Polymer.dom(pn).removeChild(s[i]);
			}
			
			return s.length;
			//document.body.removeChild(d);
		}
		
		function swapChildren(d, skip) {
			var i, f = document.createDocumentFragment();;
			for(i = 0; i < d.childNodes.length; i++)
				f.appendChild(d.childNodes[i]);
			
			d.parentNode.appendChild(f, d);
			//d.parentNode.removeChild(d);
		}
	})();
</script>
